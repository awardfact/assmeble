<어셈블리 언어란>
어셈블리 언어는 컴퓨터 언어의 일종으로 기계어를 1:1로 매핑할 수 있는 가장 저 레벨의 언어이다 
어셈블리 언어는 CPU, 레지스터, 메모리 사이의 데이터를 조작하는 것을 주로 하며 C기준으로 볼 떄 어셈블리 언어에서
사용하는 함수는 CPU에 내장되어있다 CPU의 함수는 전통적으로 instruction 이라는 명칭으로 많이 사용한다 
따라서 어셈블리 언어로 프로그래밍 한다는 것은 CPU의 함수만을 사용하여 구현하고자 하는 기능을 구현한다고 말할 수 있다
CPU에서 지원하는 함수가 너무 저 레벨이라 로직을 구현하기 위해서는 반복적인 많은 일을 해야하는데 이렇게 반복되는 작업을
미리 함수로 구현해서 제공하는 것이 어셈블리 언어 입장에서는 운영체제이다 이외에도 하드웨어 제어를 위해 컴퓨터 메인보드
롬 바이오스라는 미리 내장되어있는 API도 사용이 가능하다 

현대 컴퓨터는 운영체제라는 기본 프로그램을 가지고 있는데 운영체제는 CPU를 비롯한 컴퓨터의 모든 리소스를 관리하기 때문에
이 운영체제가 정해놓은 규칙을 준수하는 바이너리만 해당 운영체제에서 실행이 가능하다 그리고 이런 규칙은 운영체제마다 다르다
따라서 특정 운영체제의 규칙을 준수핮는 바이너리는 다른 운영체제에서 실행을 할 수 없다
그리고 CPU에 있는 함수들은 기능이 너무 빈약해 좀 더 고급 기능이 필요한데 이런 고급기능의 함수를 제공하는것이 운영체제이다
운영체제의 고급 함수도 근본적으로는 CPU에 있는 저 레벨 함수로 만들어지지만 프로그램을 할 때마다 저 레벨을 이용해서
고급함수를 만드는것은 매우 비효율적이기 때문에 운영체제를 사용하는것이다 따라서 어셈블리 소스는 좋든 싫든
실행될 운영체제가 무엇인가에 따라 코드가 달라지게 된다

어셈블리 언어로 작성된 소스를 기계에서 실행 가능하게 바이너리(기계어)로 변환하는 프로그램을 어셈블러라고 한다
바이너리가 실행되려면 1. 기계어로 만들고 2. 필요한 라이브러리를 모두 저 레벨 함수로 결합하는 링킹 기능이 필요한데
이러한 기능을 하는것이 링커이다 
어셈블리를 어셈블러를 이용하여 기계어로 만들고(중간코드) 이 기계어를 링커를 이용해서 실행 파일로 만든다


어셈블리 언어로 프로그래밍하는것은 고급 언어에 비해 규칙이 단순하며 반복적인 부분이 많다 이런 이유로 편의를 위해
내부적으로 많은 매크로를 사용하게 되는데 이러한 매크로는 사용하는 어셈블러에 따라 각각 다르다 이러한 매크로의 차이에
의해 서로 다른 어셈블러는 소스 호환이 되지 않는 문제가 발생한다 윈도우에서는 주로 MASM어셈블러를 사용하며
리눅스/유닉스 계열은 GAS라는 어셈블러를 사용했다  

책에서는 윈도우 유닉스/리눅스 에서 공통으로 동작하는 NASM이라는 어셈블러를 사용한다 
그리고 GUI환경에서 편리하게 개발할 수 있도록 하는 SASM이라는 어셈블리 언어 통합 개발 환경과 GUI환경을 같이 사용한다
SASM은 화면 및 키보드 입출력 관련해서 서로 다른 운영체제 서비스 부분을 추상화 한 간단한 공통 매크로 함수를
제공해 초기에는 운영체제에 무관하게 이런 매크로 함수를 사용하여 진행하였다

어셈블리 언어에서 사용하는 문법 표기는 크게 2가지로 나뉘어지는데 인텔 표기법과 AT&T표기법이 있다
인텔 ex)  mov eax, 3 
AT&T ex) mov $3 , %eax
인텔 표기는 윈도우 기반에서 주로 사용되고 AT&T는 주로 리눅스 계열에서 많이 사용된다 책에서는 인텔 표기법으로 사용
현재 사용되고 있는 많은 어셈블러들은 위의 2가지중 1가지를 지원한다 NASM이 인텔표기를 지원한다
특히 코드는 특수한 경우를 제외하고는 대소문자를 구분하지 않는다 주석은 세미콜론(;)을 이용한다

설치는
https://dman95.github.io/SASM/english.html여기 들어가서 
Download for windows 클릭
설치 후 setting->setting클릭하고 build탭에서 mode는 x64, assembler는 nasm으로 설정한다 

</어셈블리 언어란>



<어셈블리 언어 기본 자원>
어셈블리 프로그래밍을 할 떄 인식해야 하는 세계는 3개의 요소로 구성된다
프로그램을 실행하면 프로그램의 명령어는 메모리(RAM)에 저장되어있고 CPU는 여기에 있는 명령어를 1개씩 가지고 와서 명령을 수행하는데
이때 필요한 임시 작업공간으로 레지스터를 사용한다 레지스터는 CPU가 사용하는 일종의 작업장으로 C언어에서 보면 아주 속도가 빠른
임시 저장소이다 CPU입장에서는 레지스터에서 데이터를 저장하고 읽어오는 것이 메모리에서 데이터를 저장하고 읽어오는 것보다 훨씬 빠르고 쉽다

어셈블리 프로그램을 작성하는 것은 CPU가 지원해 주는 각종 연산 기능들을 이용하여 레지스터나 메모리에 데이터를 저장하고
프로그램의 흐름을 변경하는 단순한 작업을 하는 것이다 단순한 로직들이 결합되어 상위의 복잡한 기능이 수행된다
요약하면 어셈블리 프로그램의 로직은 데이터 이동, 각종 연산, 실행 흐름 제어로 정리될 수 있다


프로그래머가 알고리즘을 구현할 떄 사용할 수 있는 특수한 변수를 레지스터라고 한다 레지스터의 크기는 설치되어있는 운영체제의
종류에 따라 다른데 64bit운영체제이면 64bit, 32bit운영체제이면 32bit를 최대로 사용할 수 있다 최근 출시되는 컴퓨터의 레지스터의 최대 크기는 64bit이다
레지스터는 데이터를 다루는 크기에 따라 각각 다른 이름으로 불러진다  A레지스터의 경우는 다음과 같다
ex) 64bit 단위 : RAX   32bit 단위 : EAX , 16bit 단위  : AX , 8bit 단위 : AH, AL

SASM으로 코딩할 때 section .text처럼 여러 이름의 section이 등장하는데 이러한 section은 특정한 목적의 데이터나 명령어를 
모아 놓은 공통 블럭이라고 생각하면 된다 그리고 동일한 종류의 section을 2회 이상 사용하는 경우도 있다 따라서 운영체제는
SASM이 만든 프로그램의 시작 주소를 global CMain 지시자로 보고 CMain이라는 주소에서부터 프로그램을 시작하게 된다
이 지시자는 어셈블러마다 조금씩 다르다 정리하면 어셈블리 언어로 코딩하는 순서는 필요한 section들을 선언하고 각각의 목적에
적합하도록 section을 완성하는 것이다 


레지스터는 주로 A,B,C,D레지스터를 사용한다 이외에도 특별한 용도의 레지스터가 있다 
A레지스터에 특정한 값을 설정하는 코드는 다음과 같다 
ex) mov eax , 0x1234(a레지스터 32bit크기에 0x1234값 저장)    mov ax, 0x1234(a레지스터 16bit크기에 0x1234저장)
    mov ax , bx(bx값을 ax로 복사)   mov  ax , ebx(ebx(32bit)값을 ax(16bit)로 복사하는건데 비트값이 달라서 오류)

</어셈블리 언어 기본 자원>


<메모리와 변수>
어셈블리에서 메모리를 사용하기 위해서는 두 가지를 결정해야 한다 첫 번째는 사용할 메모리의 크기를 결정하고 두 번쨰는
사용할 메모리의 위치를 결정하는 것이다 코드 작성 시점에서 메모리의 크기는 프로그래머가 결정할 수 있지만 메모리에서 사용할 주소는
알 수 없기 때문에 심벌로 결정하고 바이너리로 변경할 떄 결정하도록 하고있다 이런 심벌을 상위 언어에서는 변수라는 표현을 사용한다
변수는 메모리의 시작 주소와 사용되는 메모리의 크기를 의미한다고 할 수 있다 따라서 변수는 3가지 속성을 가지고 있다
시작 주소, 저장되어 있는 값, 데이터의 크기 

초기화되지 않은 변수는 section .bss블록에서 선언해야 하며, 사용하고자 하는 큭기와 변수 개수를 지정하면된다
ex) section .bss 변수이름 크기지시자 개수  
ex) section .bss a resb 1 
초기화되지 않은 변수 크기지시자( resb : 1byte , resw : 2byte , resd : 4byte , resq : 8byte)
초기값이 결정된 변수는 section .data블록에서 선언하며 사용 예는 다음과 같다
ex) section .data 변수이름 크기지시자 초기값
ex) section .data a db 0x12
초기값 있는 변수 크기지시자( db : 1byte , dw : 2byte , dd : 4byte , dq : 8byte)
초기값을 가지고 선언된 변수여도 코드에서 필요에 따라 변경하는 것이 가능하다 

메모리를 다루기 위해서는 변수를 사용해야 하며 변수는 크기,주소값,실제 저장된 값을 가지고 있다
메모리에 데이터를 보내는 명령어는 mov를 가장 많이 사용한다 보통 어셈블리 언어에서
메모리 변수이름은 주소값을 나타내며 주소가 가리키는 곳의 값은 "[변수이름]"형식으로 표현한다
ex) mov ax,[a] (변수 a에 저장되어 있는 값을 ax레지스터에 복사)
메모리 변수를 선언하면서 크기를 정해 주었다고 해도 CPU명령어들은 메모리에서 얼마의 크기로
다루어야할지 모르기 때문에 반드시 명시적으로 다루는 데이터의 크기를 명시해야 한다
이를 지키기 않으면 에러가 발생한다 
ex) mov [a], 0x34  ( 0x34의 크기를 명시하지 않아서 오류 발생)
ex) mov [a] , byte 0x34 (0x34의 크기를 지정해주었기 때문에 오류가 발생하지 않는다)

레지스터 및 메모리에 있는 값을 출력하기 위해서는 CPU에 있는 명령어 만으로는 어렵다 이러한
기능은 운영체제에 포함되어 있는데 운영체제마다 구체적인 코드들이 다르기 때문에 각각의
운영체제마다 다르게 공부하여야 한다 
SASM에서는 운영체제와 무관하게 제공하는 매크로 함수가 있어 운영체제와 무관하게 동일한
문법으로 입출력을 수행할 수 있다 물론 내부는 각각의 운영체제마다 입출력 함수를
준비하여 실행되는 환경에 대응하도록 되어있다  
SASM에서 지원하는 입출력 매크로 함수는 다음과 같으며 출력 결과는 output에 출력된다
PRINT_HEX  바이트 수 , 레지스터 또는 변수 이름 : 레지스터 또는 변수 값을 16진수로 출력
PRINT_DEC 바이트 수 , 레지스터 또는 변수이름 : 레지스터 또는 변수 값을 10진수로 출력
NEWLINE : 화면에 줄 변경을 출력
ex) PRINT HEX 2 , ax (ax레지스터의 값을  2byte단위로 16진수로 출력)
ex) PRINT_DEC 2 , ax (ax레지스터 값을 2byte단위로 10진수로 출력)


변수 a를 4byte로 예약하고 0x12345678을 이동시키면 메모리의 구조는 다음과 같이 된다
10 11 12 13  14 
78 56 34 12
우리가 쓰는 순서와는 반대로 들어간다 즉 가장 작은 자리의 값이 작은 주소에 먼저 들어간다
이러한 방식을 리틀엔디언이라고 한다 이와 반대 표현을 빅 엔디언이라고 하며 SPARK, RISC계열 CPU가 이런 방식을 사용한다
이런 표기법 차이는 CPU내부에서 연산을 더 빠르게 하기위한 전략과 관계가 있다

만약 a라는 메모리에 0x12fmf 2byte로 전송한다면 메모리는 이런 상태가 된다
100  101
12    00  
0x12로 표현한 것을 2byte로 확장하면 0x0012가 된다




</메모리와 변수>




<문자열>
SASM에서 제공하는 매크로 함수 중 문자열을 출력할 수 있는 함수는 PRINT_STRING이다 입력 파라미터로는 출력할 문자열이
시작되는 곳의 주소를 넣어주면 된다 출력할 문자열은 section .data에 바이트의 연속으로 선언하면 된다 
주의해야 하는 것은 문장 종료를 나타내는 0x00을 마지막에 추가해 주어야 문장의 끝을 인식한다  모든 어셈블러가
이런 방법으로 다루지는 않지만 SASM에서는 이 방식을 사용 
문법 형식은 다음과 같다
ex) PRINT_STRING para  (para : 출력할 곳의 주소, 문자열 종료는 0x00으로 표시가 되어야 한다 )
ex) msg db 'hello ' , 0x00
문자열에 캐리지 리턴(0xOD) 또는 라인 피드(0x0A)를 포함하면 PRINT_STRING
매크로 함수는 c처럼 output창의 줄을 변경하여 문자열을 출력해준다 
윈도우는 0x0D , 0x0A의 연속 문자를 유닉스는 0x0A만을 줄 변경을 수행할 수 있는데
SASM의 경우는 실행하는 운영체제에 따라 다른 반응을 해준다 그리고 NASM에서
문자열은'' 또는 ""을 사용해도 모두 허용된다 

어셈블러 프로그램에서 사용자로부터 키보드를 통해 입력을 받으려면 다양한 시스템
서비스를 받아야 한다 SASM의 환경에서는 오른쪽에 있는 input창에 숫자를 입력하면
두 수는 엔터로 다른줄에 표시되는데 미리 입력된 숫자는 프로그램에서 차례로 아래 함수로 입력받을 수 있다
GET_DEC para1, para2(키보드로 입력된 문자열을 10진수로 인식 , praa1 - 입력할 바이트 수 , papa2 - 입력받을 곳으로 레지스터 또는 메모리 주소)
GET_HEX para1, para2(키보드로 입력된 값은 16진수로 인식 , para1 -입력할 바이트 수 , para2 -입력받을 곳으로 레지스터 또는 메모리 주소)



</문자열>


<연산>
어셈블리에서 더하기는 가장 기본적인 연산이다 intel CPU에서 쓸 수 있는 더하기
명령어의 형식은 아래와 같다 
ADD para1, para2 (para1 = para1 + para2)
-para1 - 레지스터 또는 메모리에 있는 값
-para2 - 레지스터 , 메모리 값
- para1, para2모두 메모리인 경우는 허용되지 않는다
section .bss에서 선언한 데이터 크기는 사람을 위한 것이여서 CPU는 알지 못한다
빼기연산은 더하기 연산과 문법적 형태가 동일하다 
SUB para1, para2(para1 = para1 - para2)
para1 - 레지스터 또는 메모리에 있는 값
para2 - 레지스터, 메모리 ,값
para1과 para2모두 메모리인 경우는 허용되지 않는다

곱하기 연산은 규칙이 복잡하다 방법이 여러가지가 있는데 쉬운 방법은 다음과 같이 한다
MUL para(1byte인 경우)
para가 1byte일 때 AX= AL * para가 된다 (AX는 2byte)
para는 레지스터만 허용된다 , 곱해지는 값은 반드시 AL레지스터에만 넣어야 한다
연산결과는 반드시 AX레지스터로만 리턴된다 
만약 2*3을 연산한다고 하면 
2를 AL레지스터에 넣고 3을 BX레지스터에 넣고 mul bx를 호출한 다음 AX을 결과값으로 사용한다
실행하기 전에 AX레지스터도 0으로 초기화 해줘야 한다 

2byte와 4byte의 경우
MUL para(2byte)
-para가 2byte일 때 DX : AX = AX * para
-para는 레지스터만 허용된다
-연산결과는 무조건 지정된 레지스터로만 들어온다(DX:AX)

MUL para(4byte)
-para가 4byte일 때 EDX: EAX = EAX* para
-para는 레지스터만 허용된다
-연산결과는 무조건 지정된 레지스터로만 들어온다 

2byte, 4byte곱하기 연산에서 특정 레지스터를 사용해서 곱할 숫자를 설정하고 결과도 지정된 레지스터로만
받는다 이떄 상위 숫자는DX(2byte의 경우) 하위 숫자는 AX레지스터로 값이 들어온다 근데 이것을 연결해서
4byte로 해석해야 하는데 인텔 CPU에서는 이것을 물리적으로 연결해 한 번에 읽어주는 명령어가 없다 
그래서 논리 연산자를 이용해서 4byte로 연결을 해야한다 
(2byte의 경우)
DX값을 edx에 넣고 AX값을 eax에 넣는다 그다음에 DX에는 shl 16을 해서 왼쪽으로 숫자를 이동시키고
edx와 eax에 or연산자를 사용하면 된다
실제 곱하기에서는 DX레지스터까지 값이 안 가능 경우가 많지만 DX까지 사용하는 경우라면 버그가 발생할 수가 있다



나누기 연산도 곱하기 연산만큼 복잡한 구조를 가지고 있다 사용은 다음과 같이 한다
DIV para(1byte인 경우)
para가 1byte일때  AX / para : AL(몫) , AH(나머지)
para는 레지스터만 허용된다
나누어지는 값은 반드시 AX레지스터에만 넣어야 한다
연산결과는 무조건 AL, AH의 고정된 레지스터로만 리턴된다 
7/2를 수행한다고 하면  나누는 수인 2를 1byte크기로 결정하면 7은 2byte인
레지스터 AX에 넣고 수행한다 결과는 AL, AH로 들어온다 인텔 CPU에서 
내부 명령어를 구현할 떄 곱하기 나누기 회로 구성이 더하기 회로를 기반으로
하기 때문에 복잡하다

2byte이상 나누기 연산은 다음과 같이 한다 
DIV para(2byte)
-para가 2byte일때 DX:AX / para(2byte) (AX - 몫 , DX- 나머지)
-para는 레지스터만 허용된다
-나누어지는 값은 무조건 DX:AX레지스터에만 넣어야 한다(DX와 AX합친 값을 para로 나누는거임)
-결과는 AX, DX의 레지스터에서만 얻을 수 있다 
4byte의 숫자를 나누기ㅣ 위해 DX,AX레지스터로 분리한 후 계산을 해야 올바른 결과를 얻을 수 있다
4byte인 EAX를 바로 사용하는 것이 아닌 DX,AX구조를 사용한다 

eax를 DX:AX로 분리는 다음과 같이 한다
eax의 값을 edx에 복사한다 , edx에는 shr edx, 16연산을 , eax에는 and eax, 0x0000ffff연산을 수행한다 


데이터르르 왼쪽이나 오른쪽 방향으로 일정 비트만큼 이동시키는 것이 shift연산이다
인텔 CPU에서 지원하는 shift연산 중 가장 기본적인 것이 다음과 같다 
SHR para1 , para2(오른쪽으로 비트 이동)
-para1 : 작업할 장수(레지스터나 메모리)
-para2 : 오른쪽으로 이동할 비트 수(주로 4의 배수로 사용)

SHL para1, para2(왼쪽으로 비트 이동)
-para1 : 작업할 장소(레지스터나 메모리)
-para2 : 왼쪽으로 이동할 비트 수 (주로 4의 배수로 사용)
이동은 기본적으로 왼쪽과 오른쪽이 있고 대부분 4bit의 배수로 이동하기 때문에 4,8,16,32bit단위로 사용한다
이동 시 밀려가는 숫자는 버려지고 빈 숫자는 0으로 채워진다

0001001000110100 (0x1234) 여기서 
왼쪽으로 4bit 0010001101000000 (0x2340)
오른쪽으로 4bit  0000000100100011(0x0123)

논리연산의 대표적인 예로는 AND , OR , XOR , NOT이 있다 각각이 의미하는 바는 수학에서 사용하는
개념과 동일하다 
 AND, OR XOR para1 , para2( para1 = para1 연산 para2)
-para1,para2 : 연산대상으로 레지스터, 메모리 상수 모두 가능
-연산결과는 para1에 저장된다
-para1, para2 모두 메모리인 경우는 연산이 불가능하다 

NOT para(para = not para, 0은 1로 , 1은 0으로 변경)
-para : 연산대상으로 레지스터 메모리 , 상수 모두 가능
- 연산결과는 para에 저장된다 

CPU는 우리가 관심을 가지고 있는 상태를 모니터링 해주는 특별한 레지스터를 운영하는데
이 레지스터를 플래그 레지스터 또는 컨트롤 레지스터라고 한다 이 레지스터를 이용하면
연산들에서 특별할 일들, 예를들어 어떤 명령어 수행결과가 0이 되었는지 또는 캐리가 발생하였는지
등의 상태를 알 수 있다 대표적인 플래그 레지스터 2개는 다음과 같다
ZF(zero flag) : 연산 결과가 Zero면 설정됨
CF(carry flag) : 연산에서 캐리가 발생하면 설정됨
플래그 레지스터는 프로그램에서 특별히 다른 레지스터처럼 명시적으로 사용되지는 않고
각각의 플래그 상태 값을 이용하는 다른 명령어들에서 비 명시적으로 사용된다
플래그 레지스터의 값을 변경시키는 명령어들은 주로 산술 논리 연산자이다 
명령어중에서 TEST연산 명령어가 있는데 이 명령어는 구조는 AND연산과 동일한데
결과를 레지스터에 반영하지 않고 플래그 레지스터에만 반영한다
TEST para1, para2
-para1과 para2의 and연산을 행하고 결과를 플래그 레지스터에 반영한다 단 para1에는 연산 결과를 반영하지 않는다



실행파일을 만들고 콘솔에서 실행
1. 새로운 프로젝트를 시작하고 코드 추가
2. 메뉴 File > Save  .exe를 선택(Ctrl+Shift+E)하고 실행파일 이름 지정
3. 저장된 실행파일 폴더에서 명령창을 열어 해당 파일 실행 


SASM에서 실행코드 디버깅 및 레지스터 내용 보기
SASM은 한줄씩 실행하면서 문제점을 파악하는 디버깅 모드를 지원하는데
디버깅 전 알아야 하는 용어는 다음과 같다
-브레이크 포인트 : 실행 도중 멈춰야 하는 곳(F8)
- 브레이크 포인트 전까지 실행 : 멈춘 곳에서 다음 브레이크 포인트가 있는 곳 전 명령어까지만 실행(F5)
-step into : 서브 함수가 있다면 내부로 실행 흐름을 변경(F11)
-step over : 서브 함수 내부로 들어가지 않고 현재 명령어를 실행(F10)
-디버깅 종료: File > Debug > Stop
1. 새로운 프로젝트 시작 후 코딩 
2. 디버깅이 필요하다고 생각되는 부분쪽에 커서를 두고 F8키를 눌러 브레이크 포인트를 정한다
3. Debug > Debug 메뉴를 선택한다(F5)
4. step over(F10)을 사용해서 다음 내용으로 간다
5. Debug > show registers(Ctrl + R)을 선택해서 레지스터 내용을 확인한다 Hex에는
해당 레지스터에 들어있는 값의 16진수 표기이며 info는 10진수 표기법 값이다 많은 레지스터가
있지만 A,B,C,D를 중점적으로 보면 된다 
6. F5로 다음 브레이크 포인트로 바로 가기를 실행한다
7. Debug> Stop으로 디버그를 종료한다

</연산>


<조건문>
어셈블리를 새로 생성하면section .text가 자동으로 생성되는데 여기서 사용되는 라벨이라는 개념은 
실행명령어가 시작되는 곳의 주소를 의미한다 (CMAIN - 이것도 라벨)
라벨이 필요한 이유는 데이터 흐름이 순차적이 아닌
앞이나 뒤로 이동해야 하는 경우가 발생하는데 이때 JMP계얼의 명령어에서 사용하기 위해 필요하다 
형식은 라벨이름을 쓴 후 콜론으로 마무리 하면 된다 (라벨:) 라벨은 명령어가 시작되는 곳에
써도 좋고 빈칸을 만들어 써도 좋지만 가독성의 차이가 있을 뿐 주소값은 없다 
라벨은 다양한 문자를 사용할 수 있다

라벨을 사용할 때 유의사항은 다음과 같다
-한 프로그램 내에서 동일한 이름의 라벨을 2개 이상 정의하지 않느다
-필요에 따라서 동일한 주소에 여러 개의 라벨을 붙여 사용하는것이 가능하다 
CMAIN라벨은 운영체제가 프로그램을 시작할 주소를 지정해주는 약속된 라벨로 SASM에서는 다른것으로 변경하면 안된다
시작 라벨의 지정은 사용하는 어셈블러 및 링커에 따라 조금씩 다르다
라벨은 라벨 뒤의 명령어가 시작되는 주소값을 의미한다 

어셈블리 언어에서는 if문이 없다 if문은 더 저차원 레벨에서 구현해야 한다
if문을 구현하기 위해서는 먼저 CMP와 JMP계열 명령어를 이해해야 한다 
쉽게 사용할 수 있는 명령어는 다음과 같다 
CMP dst, src
-dst중심으로 src와 비교 연산을 수행한다
-연산 결과는 플래그 레지스터에 저장된다
-결과는 JMP명령문과 연결되어 사용된다 

JMP 계열 명령어 (플래그 레지스터의 플래그를 보고 수행됨)
-JE/JNE label : 같거나 / 같지 않다면 label로 jump(dst == src, dst != src)
-JG/JGE label : 크거나 / 크거나 같으면 labe로 jump(dst > src , dst >= src)
-JL/JLE label : 작거나/ 작거나 같으면 label로 jump(dst<src , dst <=src)
-JMP label : label로 무조건 jump
if문을 구현하기 위해 이 두개 명령어는 쌍으로 사용된다 
C와 어셈블리 언어는 참 거짓을 처리하는 블록의 위치가 정반대로 되어있다
C의 경우 참이면 바로 이어지는 블록에서 로직을 처리하는데 어셈블리에서는 JMP명령어를
사용해서 블록이 뒤쪽으로 가게된다 또한  거짓 블록이 끝났을 때 명시적으로 블록 탈출하는
명령을 사용하지 않으면 참인 블록이 실행될 수 있어서 주의해야한다 
어셈블리 언어는 로직 구현명령이 저차원이여서 동일한 로직을 다향한 표현법으로 표현이 가능해서
블록의 위치를 변경할 수도 있다


</조건문>

