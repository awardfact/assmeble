<어셈블리 언어란>
어셈블리 언어는 컴퓨터 언어의 일종으로 기계어를 1:1로 매핑할 수 있는 가장 저 레벨의 언어이다 
어셈블리 언어는 CPU, 레지스터, 메모리 사이의 데이터를 조작하는 것을 주로 하며 C기준으로 볼 떄 어셈블리 언어에서
사용하는 함수는 CPU에 내장되어있다 CPU의 함수는 전통적으로 instruction 이라는 명칭으로 많이 사용한다 
따라서 어셈블리 언어로 프로그래밍 한다는 것은 CPU의 함수만을 사용하여 구현하고자 하는 기능을 구현한다고 말할 수 있다
CPU에서 지원하는 함수가 너무 저 레벨이라 로직을 구현하기 위해서는 반복적인 많은 일을 해야하는데 이렇게 반복되는 작업을
미리 함수로 구현해서 제공하는 것이 어셈블리 언어 입장에서는 운영체제이다 이외에도 하드웨어 제어를 위해 컴퓨터 메인보드
롬 바이오스라는 미리 내장되어있는 API도 사용이 가능하다 

현대 컴퓨터는 운영체제라는 기본 프로그램을 가지고 있는데 운영체제는 CPU를 비롯한 컴퓨터의 모든 리소스를 관리하기 때문에
이 운영체제가 정해놓은 규칙을 준수하는 바이너리만 해당 운영체제에서 실행이 가능하다 그리고 이런 규칙은 운영체제마다 다르다
따라서 특정 운영체제의 규칙을 준수핮는 바이너리는 다른 운영체제에서 실행을 할 수 없다
그리고 CPU에 있는 함수들은 기능이 너무 빈약해 좀 더 고급 기능이 필요한데 이런 고급기능의 함수를 제공하는것이 운영체제이다
운영체제의 고급 함수도 근본적으로는 CPU에 있는 저 레벨 함수로 만들어지지만 프로그램을 할 때마다 저 레벨을 이용해서
고급함수를 만드는것은 매우 비효율적이기 때문에 운영체제를 사용하는것이다 따라서 어셈블리 소스는 좋든 싫든
실행될 운영체제가 무엇인가에 따라 코드가 달라지게 된다

어셈블리 언어로 작성된 소스를 기계에서 실행 가능하게 바이너리(기계어)로 변환하는 프로그램을 어셈블러라고 한다
바이너리가 실행되려면 1. 기계어로 만들고 2. 필요한 라이브러리를 모두 저 레벨 함수로 결합하는 링킹 기능이 필요한데
이러한 기능을 하는것이 링커이다 
어셈블리를 어셈블러를 이용하여 기계어로 만들고(중간코드) 이 기계어를 링커를 이용해서 실행 파일로 만든다


어셈블리 언어로 프로그래밍하는것은 고급 언어에 비해 규칙이 단순하며 반복적인 부분이 많다 이런 이유로 편의를 위해
내부적으로 많은 매크로를 사용하게 되는데 이러한 매크로는 사용하는 어셈블러에 따라 각각 다르다 이러한 매크로의 차이에
의해 서로 다른 어셈블러는 소스 호환이 되지 않는 문제가 발생한다 윈도우에서는 주로 MASM어셈블러를 사용하며
리눅스/유닉스 계열은 GAS라는 어셈블러를 사용했다 

책에서는 윈도우 유닉스/리눅스 에서 공통으로 동작하는 NASM이라는 어셈블러를 사용한다 
그리고 GUI환경에서 편리하게 개발할 수 있도록 하는 SASM이라는 어셈블리 언어 통합 개발 환경과 GUI환경을 같이 사용한다
SASM은 화면 및 키보드 입출력 관련해서 서로 다른 운영체제 서비스 부분을 추상화 한 간단한 공통 매크로 함수를
제공해 초기에는 운영체제에 무관하게 이런 매크로 함수를 사용하여 진행하였다

어셈블리 언어에서 사용하는 문법 표기는 크게 2가지로 나뉘어지는데 인텔 표기법과 AT&T표기법이 있다
인텔 ex)  mov eax, 3 
AT&T ex) mov $3 , %eax
인텔 표기는 윈도우 기반에서 주로 사용되고 AT&T는 주로 리눅스 계열에서 많이 사용된다 책에서는 인텔 표기법으로 사용
현재 사용되고 있는 많은 어셈블러들은 위의 2가지중 1가지를 지원한다 NASM이 인텔표기를 지원한다
특히 코드는 특수한 경우를 제외하고는 대소문자를 구분하지 않는다 주석은 세미콜론(;)을 이용한다

설치는
https://dman95.github.io/SASM/english.html여기 들어가서 
Download for windows 클릭
설치 후 setting->setting클릭하고 build탭에서 mode는 x64, assembler는 nasm으로 설정한다 

</어셈블리 언어란>



<어셈블리 언어 기본 자원>
어셈블리 프로그래밍을 할 떄 인식해야 하는 세계는 3개의 요소로 구성된다
프로그램을 실행하면 프로그램의 명령어는 메모리(RAM)에 저장되어있고 CPU는 여기에 있는 명령어를 1개씩 가지고 와서 명령을 수행하는데
이때 필요한 임시 작업공간으로 레지스터를 사용한다 레지스터는 CPU가 사용하는 일종의 작업장으로 C언어에서 보면 아주 속도가 빠른
임시 저장소이다 CPU입장에서는 레지스터에서 데이터를 저장하고 읽어오는 것이 메모리에서 데이터를 저장하고 읽어오는 것보다 훨씬 빠르고 쉽다

어셈블리 프로그램을 작성하는 것은 CPU가 지원해 주는 각종 연산 기능들을 이용하여 레지스터나 메모리에 데이터를 저장하고
프로그램의 흐름을 변경하는 단순한 작업을 하는 것이다 단순한 로직들이 결합되어 상위의 복잡한 기능이 수행된다
요약하면 어셈블리 프로그램의 로직은 데이터 이동, 각종 연산, 실행 흐름 제어로 정리될 수 있다


프로그래머가 알고리즘을 구현할 떄 사용할 수 있는 특수한 변수를 레지스터라고 한다 레지스터의 크기는 설치되어있는 운영체제의
종류에 따라 다른데 64bit운영체제이면 64bit, 32bit운영체제이면 32bit를 최대로 사용할 수 있다 최근 출시되는 컴퓨터의 레지스터의 최대 크기는 64bit이다
레지스터는 데이터를 다루는 크기에 따라 각각 다른 이름으로 불러진다  A레지스터의 경우는 다음과 같다
ex) 64bit 단위 : RAX   32bit 단위 : EAX , 16bit 단위  : AX , 8bit 단위 : AH, AL

SASM으로 코딩할 때 section .text처럼 여러 이름의 section이 등장하는데 이러한 section은 특정한 목적의 데이터나 명령어를 
모아 놓은 공통 블럭이라고 생각하면 된다 그리고 동일한 종류의 section을 2회 이상 사용하는 경우도 있다 따라서 운영체제는
SASM이 만든 프로그램의 시작 주소를 global CMain 지시자로 보고 CMain이라는 주소에서부터 프로그램을 시작하게 된다
이 지시자는 어셈블러마다 조금씩 다르다 정리하면 어셈블리 언어로 코딩하는 순서는 필요한 section들을 선언하고 각각의 목적에
적합하도록 section을 완성하는 것이다 


레지스터는 주로 A,B,C,D레지스터를 사용한다 이외에도 특별한 용도의 레지스터가 있다 
A레지스터에 특정한 값을 설정하는 코드는 다음과 같다 
ex) mov eax , 0x1234(a레지스터 32bit크기에 0x1234값 저장)    mov ax, 0x1234(a레지스터 16bit크기에 0x1234저장)
    mov ax , bx(bx값을 ax로 복사)   mov  ax , ebx(ebx(32bit)값을 ax(16bit)로 복사하는건데 비트값이 달라서 오류)

</어셈블리 언어 기본 자원>


<메모리와 변수>
어셈블리에서 메모리를 사용하기 위해서는 두 가지를 결정해야 한다 첫 번째는 사용할 메모리의 크기를 결정하고 두 번쨰는
사용할 메모리의 위치를 결정하는 것이다 코드 작성 시점에서 메모리의 크기는 프로그래머가 결정할 수 있지만 메모리에서 사용할 주소는
알 수 없기 때문에 심벌로 결정하고 바이너리로 변경할 떄 결정하도록 하고있다 이런 심벌을 상위 언어에서는 변수라는 표현을 사용한다
변수는 메모리의 시작 주소와 사용되는 메모리의 크기를 의미한다고 할 수 있다 따라서 변수는 3가지 속성을 가지고 있다
시작 주소, 저장되어 있는 값, 데이터의 크기 

초기화되지 않은 변수는 section .bss블록에서 선언해야 하며, 사용하고자 하는 큭기와 변수 개수를 지정하면된다
ex) section .bss 변수이름 크기지시자 개수  
ex) section .bss a resb 1 
초기화되지 않은 변수 크기지시자( resb : 1byte , resw : 2byte , resd : 4byte , resq : 8byte)
초기값이 결정된 변수는 section .data블록에서 선언하며 사용 예는 다음과 같다
ex) section .data 변수이름 크기지시자 초기값
ex) section .data a db 0x12
초기값 있는 변수 크기지시자( db : 1byte , dw : 2byte , dd : 4byte , dq : 8byte)
초기값을 가지고 선언된 변수여도 코드에서 필요에 따라 변경하는 것이 가능하다 

메모리를 다루기 위해서는 변수를 사용해야 하며 변수는 크기,주소값,실제 저장된 값을 가지고 있다
메모리에 데이터를 보내는 명령어는 mov를 가장 많이 사용한다 보통 어셈블리 언어에서
메모리 변수이름은 주소값을 나타내며 주소가 가리키는 곳의 값은 "[변수이름]"형식으로 표현한다
ex) mov ax,[a] (변수 a에 저장되어 있는 값을 ax레지스터에 복사)
메모리 변수를 선언하면서 크기를 정해 주었다고 해도 CPU명령어들은 메모리에서 얼마의 크기로
다루어야할지 모르기 때문에 반드시 명시적으로 다루는 데이터의 크기를 명시해야 한다
이를 지키기 않으면 에러가 발생한다 
ex) mov [a], 0x34  ( 0x34의 크기를 명시하지 않아서 오류 발생)
ex) mov [a] , byte 0x34 (0x34의 크기를 지정해주었기 때문에 오류가 발생하지 않는다)

레지스터 및 메모리에 있는 값을 출력하기 위해서는 CPU에 있는 명령어 만으로는 어렵다 이러한
기능은 운영체제에 포함되어 있는데 운영체제마다 구체적인 코드들이 다르기 때문에 각각의
운영체제마다 다르게 공부하여야 한다 
SASM에서는 운영체제와 무관하게 제공하는 매크로 함수가 있어 운영체제와 무관하게 동일한
문법으로 입출력을 수행할 수 있다 물론 내부는 각각의 운영체제마다 입출력 함수를
준비하여 실행되는 환경에 대응하도록 되어있다  
SASM에서 지원하는 입출력 매크로 함수는 다음과 같으며 출력 결과는 output에 출력된다
PRINT_HEX  바이트 수 , 레지스터 또는 변수 이름 : 레지스터 또는 변수 값을 16진수로 출력
PRINT_DEC 바이트 수 , 레지스터 또는 변수이름 : 레지스터 또는 변수 값을 10진수로 출력
NEWLINE : 화면에 줄 변경을 출력
ex) PRINT HEX 2 , ax (ax레지스터의 값을  2byte단위로 16진수로 출력)
ex) PRINT_DEC 2 , ax (ax레지스터 값을 2byte단위로 10진수로 출력)


변수 a를 4byte로 예약하고 0x12345678을 이동시키면 메모리의 구조는 다음과 같이 된다
10 11 12 13  14 
78 56 34 12
우리가 쓰는 순서와는 반대로 들어간다 즉 가장 작은 자리의 값이 작은 주소에 먼저 들어간다
이러한 방식을 리틀엔디언이라고 한다 이와 반대 표현을 빅 엔디언이라고 하며 SPARK, RISC계열 CPU가 이런 방식을 사용한다
이런 표기법 차이는 CPU내부에서 연산을 더 빠르게 하기위한 전략과 관계가 있다

만약 a라는 메모리에 0x12fmf 2byte로 전송한다면 메모리는 이런 상태가 된다
100  101
12    00  
0x12로 표현한 것을 2byte로 확장하면 0x0012가 된다




</메모리와 변수>
SASM에서 제공하는 매크로 함수 중 문자열을 출력할 수 있는 함수는 PRINT_STRING이다 입력 파라미터로는 출력할 문자열이
시작되는 곳의 주소를 넣어주면 된다 출력할 문자열은 section .data에 바이트의 연속으로 선언하면 된다 
주의해야 하는 것은 문장 종료를 나타내는 0x00을 마지막에 추가해 주어야 문장의 끝을 인식한다  모든 어셈블러가
이런 방법으로 다루지는 않지만 SASM에서는 이 방식을 사용 



<문자열>




</문자열>


