<어셈블리 언어란>
어셈블리 언어는 컴퓨터 언어의 일종으로 기계어를 1:1로 매핑할 수 있는 가장 저 레벨의 언어이다 
어셈블리 언어는 CPU, 레지스터, 메모리 사이의 데이터를 조작하는 것을 주로 하며 C기준으로 볼 떄 어셈블리 언어에서
사용하는 함수는 CPU에 내장되어있다 CPU의 함수는 전통적으로 instruction 이라는 명칭으로 많이 사용한다 
따라서 어셈블리 언어로 프로그래밍 한다는 것은 CPU의 함수만을 사용하여 구현하고자 하는 기능을 구현한다고 말할 수 있다
CPU에서 지원하는 함수가 너무 저 레벨이라 로직을 구현하기 위해서는 반복적인 많은 일을 해야하는데 이렇게 반복되는 작업을
미리 함수로 구현해서 제공하는 것이 어셈블리 언어 입장에서는 운영체제이다 이외에도 하드웨어 제어를 위해 컴퓨터 메인보드
롬 바이오스라는 미리 내장되어있는 API도 사용이 가능하다 

현대 컴퓨터는 운영체제라는 기본 프로그램을 가지고 있는데 운영체제는 CPU를 비롯한 컴퓨터의 모든 리소스를 관리하기 때문에
이 운영체제가 정해놓은 규칙을 준수하는 바이너리만 해당 운영체제에서 실행이 가능하다 그리고 이런 규칙은 운영체제마다 다르다
따라서 특정 운영체제의 규칙을 준수핮는 바이너리는 다른 운영체제에서 실행을 할 수 없다
그리고 CPU에 있는 함수들은 기능이 너무 빈약해 좀 더 고급 기능이 필요한데 이런 고급기능의 함수를 제공하는것이 운영체제이다
운영체제의 고급 함수도 근본적으로는 CPU에 있는 저 레벨 함수로 만들어지지만 프로그램을 할 때마다 저 레벨을 이용해서
고급함수를 만드는것은 매우 비효율적이기 때문에 운영체제를 사용하는것이다 따라서 어셈블리 소스는 좋든 싫든
실행될 운영체제가 무엇인가에 따라 코드가 달라지게 된다

어셈블리 언어로 작성된 소스를 기계에서 실행 가능하게 바이너리(기계어)로 변환하는 프로그램을 어셈블러라고 한다
바이너리가 실행되려면 1. 기계어로 만들고 2. 필요한 라이브러리를 모두 저 레벨 함수로 결합하는 링킹 기능이 필요한데
이러한 기능을 하는것이 링커이다 
어셈블리를 어셈블러를 이용하여 기계어로 만들고(중간코드) 이 기계어를 링커를 이용해서 실행 파일로 만든다


어셈블리 언어로 프로그래밍하는것은 고급 언어에 비해 규칙이 단순하며 반복적인 부분이 많다 이런 이유로 편의를 위해
내부적으로 많은 매크로를 사용하게 되는데 이러한 매크로는 사용하는 어셈블러에 따라 각각 다르다 이러한 매크로의 차이에
의해 서로 다른 어셈블러는 소스 호환이 되지 않는 문제가 발생한다 윈도우에서는 주로 MASM어셈블러를 사용하며
리눅스/유닉스 계열은 GAS라는 어셈블러를 사용했다 

책에서는 윈도우 유닉스/리눅스 에서 공통으로 동작하는 NASM이라는 어셈블러를 사용한다 
그리고 GUI환경에서 편리하게 개발할 수 있도록 하는 SASM이라는 어셈블리 언어 통합 개발 환경과 GUI환경을 같이 사용한다
SASM은 화면 및 키보드 입출력 관련해서 서로 다른 운영체제 서비스 부분을 추상화 한 간단한 공통 매크로 함수를
제공해 초기에는 운영체제에 무관하게 이런 매크로 함수를 사용하여 진행하였다

어셈블리 언어에서 사용하는 문법 표기는 크게 2가지로 나뉘어지는데 인텔 표기법과 AT&T표기법이 있다
인텔 ex)  mov eax, 3 
AT&T ex) mov $3 , %eax
인텔 표기는 윈도우 기반에서 주로 사용되고 AT&T는 주로 리눅스 계열에서 많이 사용된다 책에서는 인텔 표기법으로 사용
현재 사용되고 있는 많은 어셈블러들은 위의 2가지중 1가지를 지원한다 NASM이 인텔표기를 지원한다
특히 코드는 특수한 경우를 제외하고는 대소문자를 구분하지 않는다 주석은 세미콜론(;)을 이용한다

설치는
https://dman95.github.io/SASM/english.html여기 들어가서 
Download for windows 클릭
설치 후 setting->setting클릭하고 build탭에서 mode는 x64, assembler는 nasm으로 설정한다 

</어셈블리 언어란>



<어셈블리 언어 기본 자원>
어셈블리 프로그래밍을 할 떄 인식해야 하는 세계는 3개의 요소로 구성된다
프로그램을 실행하면 프로그램의 명령어는 메모리(RAM)에 저장되어있고 CPU는 여기에 있는 명령어를 1개씩 가지고 와서 명령을 수행하는데
이때 필요한 임시 작업공간으로 레지스터를 사용한다 레지스터는 CPU가 사용하는 일종의 작업장으로 C언어에서 보면 아주 속도가 빠른
임시 저장소이다 CPU입장에서는 레지스터에서 데이터를 저장하고 읽어오는 것이 메모리에서 데이터를 저장하고 읽어오는 것보다 훨씬 빠르고 쉽다

어셈블리 프로그램을 작성하는 것은 CPU가 지원해 주는 각종 연산 기능들을 이용하여 레지스터나 메모리에 데이터를 저장하고
프로그램의 흐름을 변경하는 단순한 작업을 하는 것이다 단순한 로직들이 결합되어 상위의 복잡한 기능이 수행된다
요약하면 어셈블리 프로그램의 로직은 데이터 이동, 각종 연산, 실행 흐름 제어로 정리될 수 있다


프로그래머가 알고리즘을 구현할 떄 사용할 수 있는 특수한 변수를 레지스터라고 한다 레지스터의 크기는 설치되어있는 운영체제의
종류에 따라 다른데 64bit운영체제이면 64bit, 32bit운영체제이면 32bit를 최대로 사용할 수 있다 최근 출시되는 컴퓨터의 레지스터의 최대 크기는 64bit이다
레지스터는 데이터를 다루는 크기에 따라 각각 다른 이름으로 불러진다  A레지스터의 경우는 다음과 같다
ex) 64bit 단위 : RAM   32bit 단위 : EAX , 16bit 단위  : AX , 8bit 단위 : AH, AL

SASM으로 코딩할 때 section .text처럼 여러 이름의 section이 등장하는데 이러한 section은 특정한 목적의 데이터나 명령어를 
모아 놓은 공통 블럭이라고 생각하면 된다 그리고 동일한 종류의 section을 2회 이상 사용하는 경우도 있다 따라서 운영체제는
SASM이 만든 프로그램의 시작 주소를 global CMain 지시자로 보고 CMain이라는 주소에서부터 프로그램을 시작하게 된다
이 지시자는 어셈블러마다 조금씩 다르다 정리하면 어셈블리 언어로 코딩하는 순서는 필요한 section들을 선언하고 각각의 목적에
적합하도록 section을 완성하는 것이다 


레지스터는 주로 A,B,C,D레지스터를 사용한다 이외에도 특별한 용도의 레지스터가 있다 
A레지스터에 특정한 값을 설정하는 코드는 다음과 같다 
ex) mov eax , 0x1234(a레지스터 32bit크기에 0x1234값 저장)    mov ax, 0x1234(a레지스터 16bit크기에 0x1234저장)
    mov ax , bx(bx값을 ax로 복사)   mov  ax , ebx(ebx(32bit)값을 ax(16bit)로 복사하는건데 비트값이 달라서 오류)

</어셈블리 언어 기본 자원>


<메모리와 변수>
어셈블리에서 메모리를 사용하기 위해서는 두 가지를 결정해야 한다 첫 번째는 사용할 메모리의 크기를 결정하고 두 번쨰는
사용할 메모리의 위치를 결정하는 것이다 코드 작성 시점에서 메모리의 크기는 프로그래머가 결정할 수 있지만 메모리에서 사용할 주소는
알 수 없기 때문에 심벌로 결정하고 바이너리로 변경할 떄 결정하도록 하고있다 이런 심벌을 상위 언어에서는 변수라는 표현을 사용한다
변수는 메모리의 시작 주소와 사용되는 메모리의 크기를 의미한다고 할 수 있다 따라서 변수는 3가지 속성을 가지고 있다
시작 주소, 저장되어 있는 값, 데이터의 크기 

</메모리와 변수>

